
- **STK-01:是否防范了“首位存款者攻击”（First Depositor / Inflation Attack）？**
    - **描述**：攻击者作为首位存款人，可以通过“铸造微量份额（如 1 wei）随后直接向合约‘捐赠’巨额资产”的方式，导致 totalAssets / totalShares汇率极高，后续用户的存款因精度取整而获得 0 份额。这导致受害者损失全部本金，而资产被留存在池中归攻击者所有。
    - **建议**：在系统初始化或首笔存款时，强制将一定数量的份额，从而显著提高攻击者操纵汇率所需的资金成本。

- **STK-02:所有 ETH 转账或外部调用是否都受到防重入保护？**
    - **描述**：在涉及 ETH 转账（call、transfer、send）或外部代币合约调用（如 ERC20.transfer、ERC777）时，恶意合约可在回调中重入 staking 合约，在状态更新前再次调用提款等函数，导致资产被重复提取。
    - **建议**：对所有涉及资产转移的函数使用 ReentrancyGuard 修饰符；严格遵循 CEI（Checks-Effects-Interactions）模式，在任何外部调用前完成状态更新；

- **STK-03:如果使用预言机，协议是否检查了过期数据？**
    - **描述**：预言机数据可能因网络问题、预言机故障或更新延迟而过期。使用过期价格数据可能导致不公平的清算、错误的份额估值或被攻击者利用进行套利，造成协议和用户损失。
    - **建议**：每次读取预言机数据时检查时间戳，拒绝超过合理时间窗口的数据。

- **STK-04: 在计算份额（Mint Shares）时，除法运算是否放在乘法之后以减少精度损失？**
    - **描述**：在 Solidity 中执行 shares = (amount * totalShares) / totalAssets 时，如果先执行除法（如 amount / totalAssets * totalShares），会因整数除法截断导致严重的精度损失，用户可能获得远少于应得的份额或完全获得 0 份额。
    - **建议**：始终遵循"先乘后除"原则，即 (a * b) / c 而非 (a / c) * b；对于复杂计算，使用定点数库（如 PRBMath）或 OpenZeppelin 的 Math 库；在单元测试中验证边界情况（如 amount < totalAssets 时的行为）；考虑使用更高精度的中间变量。

- **STK-05: 是否在循环中包含了外部调用或无限制的数组遍历（可能导致 Gas Limit 耗尽）？**
    - **描述**：如果在循环中执行外部调用（如批量发放奖励时调用 token.transfer）或遍历无界限的用户/代币数组，当数组增长到一定规模时，单笔交易的 gas 消耗会超过区块 gas 上限，形成 DoS（拒绝服务）。
    - **建议**：避免在单笔交易中遍历大型数组；使用分页模式或迭代器允许分批处理；为数组大小设置合理上限；将批量操作改为 pull 模式，让用户各自领取；

- **STK-06: 奖励分发速率（Reward Rate）改变时，是否正确结算了上一周期的剩余奖励？**
    - **描述**：当管理员更新奖励速率时，如果未先结算从上次更新到当前时刻累积的奖励，会导致这段时间的奖励按新速率（而非旧速率）计算，造成用户获得错误的奖励金额。攻击者可能通过在高奖励期前质押、速率降低前提款来套利。
    - **建议**：在修改奖励速率之前，必须调用 updateReward() 或类似函数，按旧速率结算所有待发放奖励并更新 lastUpdateTime；使用 rewardPerTokenStored 累积每单位份额的历史奖励；确保新速率仅对未来时间生效；在测试中验证速率变更前后奖励计算的连续性。

- **STK-07: 攻击者能否通过闪电贷操纵 TVL、份额价值或代币价格？**
    - **描述**：攻击者可利用闪电贷在单笔交易内暂时大幅增加 TVL，触发基于即时 TVL 的奖励分配、份额价格计算或治理权重，在操纵期间获利（如铸造大量份额、参与治理投票、触发清算）后归还贷款，不承担长期风险。
    - **建议**：关键指标使用时间加权平均值（TWAP）而非即时快照；奖励和治理权重基于历史数据（如上个区块或多区块平均）；要求最小质押时长（如 1 个区块）才能参与治理或获得奖励；检测并标记单区块内的异常大额操作；对依赖外部价格的功能使用去中心化预言机而非 DEX 即时价格。

- **STK-08: 是否设置了最小/最大存款限额？**
    - **描述**：缺少最小限额导致精度损失、粉尘攻击和首位存款攻击风险；缺少最大限额可能引发中心化风险、整数溢出和流动性危机。
    - **建议**：设置最小存款金额（如 0.001 ETH 或 10 USDC）；设置最大单次存款限额（如不超过 TVL 的 10%）或单用户持仓上限（如不超过总份额的 20%）；特殊需求通过白名单处理。

- **STK-09: 特权角色是否最小化并通过多重签名或 DAO 治理进行保护？**
    - **描述**：单一私钥控制的特权角色存在被盗、作恶或单点故障风险，可能导致用户资金损失、参数被恶意修改或合约被暂停。
    - **建议**：将管理功能拆分为多个最小权限角色；关键操作使用多重签名钱包控制；实施时间锁；

- **STK-10: 是否对所有受限操作强制执行了暂停状态（Paused State）检查？**
    - **描述**：如果暂停机制实施不完整，某些关键函数（如存款、提款、领取奖励）在紧急情况下仍可被调用，导致暂停失效，无法阻止攻击继续进行或防止用户在漏洞修复前继续操作。
    - **建议**：使用 whenNotPaused 修饰符保护所有状态变更函数（stake、withdraw、claimRewards 等）。

- **STK-11: 是否正确处理了 Fee-on-Transfer Tokens（通缩代币）？**
    - **描述**：某些代币在每次转账时会自动扣除手续费，导致合约实际收到的金额少于 transferFrom 参数中的 amount。如果合约直接用 amount 铸造份额或更新账本，会导致内部记录的资产总额大于实际余额，
    - **建议**：在 transferFrom 调用前后检查合约余额变化, 使用 actualReceived 而非 amount 进行份额计算和账本更新；在文档中明确说明是否支持通缩代币；或直接禁用通缩代币，在白名单中排除此类资产。

- **STK-12: 份额兑换计算中的舍入方向是否始终有利于协议（存款向下舍入，提款向下舍入）以保证偿付能力？**
    - **描述**：在整数除法运算中，舍入方向直接影响协议的偿付能力。如果存款时向上舍入份额或提款时向上舍入资产，攻击者可通过多次小额操作累积舍入误差，逐步抽干合约资产。
    - **建议**：存款时向下舍入份额 ,提款时向下舍入资产 , 使用有利于协议舍入方向。

- **STK-13: 当总质押量（Total Staked）为 0 时，汇率计算是否有默认值保护（避免除以零）？**
    - **描述**：当 totalShares 或 totalAssets 为 0 时，份额计算公式 shares = amount * totalShares / totalAssets 会触发除零错误导致交易回退，或在某些逻辑中返回异常值，阻止首位用户存款或导致合约初始化失败。
    - **建议**：在份额计算中显式处理零值情况。

- **STK-14: 提款条目是否唯一且受重放保护？**
    - **描述**：如果提款请求缺少唯一性约束，攻击者可能重复提交相同的提款请求（重放攻击），多次提取同一笔资金；或通过伪造/复制其他用户的提款凭证来窃取资金，导致合约资金被掏空。
    - **建议**：为每个提款请求生成唯一 ID，提款执行后立即标记为已处理；在测试中验证同一请求无法被执行两次。

- **STK-15:  锁定期（Lockup Period）逻辑是否能被“追加存款”恶意重置或绕过？**
    - **描述**： 如果协议允许追加存款而不更新锁定时间，用户可能通过先存小额锁定，临期时存入大额并立即解锁，绕过锁定期限制。 
    - **建议**： 将不同期限的存款区分管理；

- **STK-16: 多重奖励代币场景下，单一代币故障是否会阻塞全局操作？**
    - **描述**： 如果协议支持同时分发多种奖励代币，在 getReward 时可能会循环转账。如果 Token B 暂停转账、余额不足或被黑名单拦截，会导致 claim 函数整体回滚，用户连正常的 Token A 也无法领取。 
    - **建议**： 在多奖励循环中，如果某个代币转账失败，记录未领取的金额并在事件中标记，确保其他奖励能正常发放；避免“一损俱损”的设计。

- **STK-17: 是否正确处理了不同代币精度（Decimals）的计算和转换？**
    - **描述**： 如果质押代币是18 decimals而奖励代币是 9 decimals。在计算 rewardPerToken 或 earned 时，如果直接相乘除而不进行精度标准化（Normalization），会导致奖励数量级相差 10^12 倍。 
    - **建议**： 显式处理不同代币的精度转换。

- **STK-18: 代理模式（Proxy Pattern）下，是否为后续升级预留了存储间隙（Storage Gap）？**
    - **描述**： 大多数 Staking 合约是可升级的。如果父合约（如 OpenZeppelin 的 ERC20Upgradeable）在升级中增加了状态变量，而子合约（Staking 逻辑）没有预留 __gap，可能会导致存储槽碰撞（Storage Collision）。 
    - **建议**： 在可升级合约的末尾声明 uint256[50] private __gap;；。

- **STK-19: 是否允许任何人添加奖励代币（Whitelisting Risk）？**
    - **描述**： 如果 addRewardToken(address token) 是公开的，攻击者可以添加恶意代币（如 Revert 转账的代币、Gas 消耗极大的代币），并将该代币注入奖励循环中。当用户尝试 getAllRewards 时，会被这个恶意代币卡住，导致所有奖励都无法领取。 
    - **建议**： addRewardToken 必须由 Owner 或 DAO 控制；或者在领取逻辑中硬性隔离，确保一个代币的失败不会影响其他代币的领取。

- **STK-20: 初始化函数（Initialize）是否被妥善保护以防被抢跑？**
    - **描述**： 对于代理合约（Proxy），逻辑合约的 initialize 函数通常没有 constructor 保护。攻击者可以监控部署交易，抢在管理员之前调用 initialize 并将自己设为 Owner，从而接管整个合约的控制权（如升级合约、提取资金）。
    - **建议**： 确保逻辑合约（Implementation）在部署时就在构造函数中调用 _disableInitializers()；在部署脚本中原子化执行“部署+初始化”。

- **STK-21: 惩罚机制（Slashing）是否会导致下溢（Underflow）或坏账？**
    - **描述**： 在某些委托权益证明（DPoS）或节点质押中，如果 Slash 罚款金额大于用户的质押余额，且代码使用 unchecked 或旧版 Solidity，可能导致余额下溢变成天文数字。或者，Slash 导致 totalAssets 减少，但未同步销毁对应的 shares，导致汇率暴涨或偿付能力不足。 
    - **建议**： Slash 操作前必须检查 amount <= userBalance；Slash 发生时应同步调整 totalStaked 和用户的份额；考虑 Slash 后的坏账处理逻辑。

- **STK-22: 奖励累积机制（如 rewardPerTokenStored）是否在每次余额变更时正确更新？**
    - **描述**：若用户在质押、提取或领取奖励时未先调用 updateReward() 来更新累积奖励，会导致奖励计算基于过期数据，使用户多领或少领奖励。攻击者可能在奖励刚更新后立即质押/提款，利用时间差获利。
    - **建议**：确保所有影响用户余额的函数（stake、withdraw、getReward）开头都调用 updateReward()；采用 modifier 统一处理。

- **STK-23: 是否允许质押代币为合约本身（Self-Staking）导致逻辑死锁？**
    - **描述**：如果质押代币地址被设置为staking合约自身地址，用户“质押”时代币转入合约，合约可能错误地将自身余额计入TVL，导致份额计算混乱或提款时无法转账（合约无法向自己发送代币）。
    - **建议**：在质押函数中检查 asset != address(this)

- **STK-24: 治理代币奖励分发时，是否检查了代币转移中的“税收”或黑名单机制？**
    - **描述**：某些代币（如USDT、USDC）可能对特定地址实施黑名单，转账失败；或如某些defi代币有转账费用。如果合约未处理这些情况，奖励分发会回滚，导致用户无法领取。
    - **建议**：在添加奖励代币时验证其是否为标准ERC20；对于已知有黑名单或费用的代币，采用“pull”模式让用户自行领取，而非合约主动推送。

- **STK-25: “质押凭证”（staking token）是否可转让（Transferable），若可转让是否会影响奖励计算和领取？**
    - **描述**：如果质押凭证（如LP token或份额代币）可转让，用户A可能在领取奖励前将凭证转给用户B，导致奖励被B领取，造成纠纷。或更严重地，转让后原所有者的奖励余额未清零，被新所有者再次领取。
    - **建议**：若奖励与地址绑定而非与代币绑定，应使质押凭证不可转让（如ERC20中重写 transfer 函数并 revert）；若允许转让，需在转账钩子中同步更新奖励归属。

- **STK-26: 是否对“短暂质押攻击”（Flash Staking Attack）进行了防护？**
    - **描述**：攻击者在奖励分发的前一秒质押，并在下一秒领取奖励后立即提现，仅质押极短时间却获得完整区块的奖励，稀释了长期质押者的收益。尤其在基于区块快照分发奖励的系统中风险高。
    - **建议**：引入基于时间的奖励权重（如质押时长越长，单位时间奖励越高）；或要求最小质押时长（如至少1个区块）才有资格获得奖励。

- **STK-27: 是否允许质押“非标准ERC20”代币（如缺少返回值）？**
    - **描述**：某些旧版ERC20（如USDT）的 transfer 不返回布尔值，导致合约调用时 revert。如果staking合约未兼容此类代币，用户将无法质押或提款。
    - **建议**：使用OpenZeppelin的 SafeERC20 库，它通过 safeTransfer 兼容非标准代币；或在接入新代币前进行充分测试。

- **STK-28: 如果遵循 ERC-4626 标准，preview 和 deposit/redeem 的结果是否严格一致？**
    - **描述**： ERC-4626 要求 previewDeposit 返回的份额必须与实际 deposit 铸造的份额完全一致（或在允许的舍入误差内）。如果合约依赖预言机或变动费率，导致执行时的状态与预览时不一致，可能导致通过此接口集成的第三方聚合器遭受三明治攻击（Sandwich Attack）。 
    - **建议**： 确保预览函数和执行函数共享完全相同的计算逻辑和状态快照；

- **STK-29: 是否在内部 Swap 中使用了硬编码的“零滑点”或“无限期限”？**
    - **描述**： 如果 Staking 合约具备“自动复投”功能，需要将奖励 Token A 换成 Token B。如果调用 Uniswap 时设置 amountOutMin: 0（零滑点保护）或 deadline: block.timestamp（容易被矿工扣留），该交易极易被三明治攻击，导致用户的复投收益归零。 
    - **建议**： 即使是内部自动复投，也应计算一个合理的 minAmountOut，或者允许用户在触发复投时传入该参数。

- **STK-30: 原生代币（ETH/BNB）的处理是否使用了 Pull 模式？**
    - **描述**： 如果合约在分发奖励或提款时直接使用 address(user).transfer(amount)，当接收方是回退（Revert）所有 ETH 接收的智能合约（或 Gas 消耗过高的合约）时，整个交易会失败。如果是批量分发，一个恶意用户就能阻塞所有人。 
    - **建议**： 采用“用户自行申领（Claim）”的 Pull 模式。

- **STK-31: 乘法数值运算前，是否进行了“类型提升”（Type Widening/Upcasting）？**
    - **描述**： 若直接对 uint64/uint128 执行乘法，极易溢出导致交易 Revert (DoS)。 
    - **建议**： 始终遵循“先扩容，再计算”原则。例如：uint256(a) * uint256(b) / c。

- **STK-32: 是否屏蔽或特殊处理了变基代币（Rebasing Tokens）？**
    - **描述**： 此类代币余额会自动变动，导致合约内部账本（internalBalance）与实际余额（balanceOf）脱锚。 
    - **建议**： 明确不支持，或使用“份额化”记账。

- **STK-33: 管理员是否能够更新奖励参数/奖励代币/锁定时间等参数，如果可以更新是否会影响更新前质押用户的质押情况？**
    - **描述**： 如果管理员在更新参数时没有考虑更新后其他质押用户的质押信息，则可能导致用户奖励/锁定时间与预期不符。 
    - **建议**： 需要在用户质押时进行质押参数记录。


